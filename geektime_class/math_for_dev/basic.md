## Binary
### 向左移位
二进制 110101 向左移一位，就是在末尾添加一位 0，因此 110101 就变成了1101010
如果将 1101010 换算为十进制，就是 106，你有没有发现，106 正好是 53 的 2 倍。所以，我们可以得出一个结论：二进制左移一位，其实就是将数字翻倍.

数字溢出，就是二进制数的位数超过了系统所指定的位数。目前主流的系统都支持至少 32 位的整型数字,如果进行左移操作的二进制已经超出了32位，左移后数字就会溢出，需要将溢出的位数去除。

### 向右移位
二进制 110101 向右移一位，就是去除末尾的那一位，因此 110101 就变成了 11010（最前面的 0 可以省略）。我们将 11010 换算为十进制，就是 26，正好是 53 除以 2 的整数商。所以二进制右移一位，就是将数字除以 2 并求整数商的操作。

### 位的或
逻辑“或”的意思是，参与操作的位中只要有一个位是 1，那么最终结果就是 1，也就是“真”。如果我们将二进制110101和100011的每一位对齐，进行按位的“或”操作，就会得到 110111。
```
110101
or
100011
=
110111
```

### 位的与
逻辑“与”的操作,“与”的意思是，参与操作的位中必须全都是 1，那么最终结果才是 1（真），否则就为 0（假）。如果我们将二进制 110101 和 100011 的每一位对齐，进行按位的“与”操作，就会得到 100001。
```
110101
and
100011
=
100001
```

### 位的异或
逻辑“异或”和“或”有所不同，它具有排异性，也就是说如果参与操作的位相同，那么最终结果就为 0（假），否则为 1（真）。所以，如果要得到1，参与操作的两个位必须不同，这就是此处“异”的含义。我们将二进制110101和100011的每一位对齐，进行按位的“异或”操作，可以得到结果是 10110
```
110101
xor ^
100011
=
010110
```

## 取余 Mod
* 余数总是在一个固定的范围内.
* 同余定理：就是两个整数 a 和 b，如果它们除以正整数m得到的余数相等，我们就可以说 a 和 b 对于模 m 同余。

利用这二个特性，同余定理就可以用来分类的。我们有无穷多个整数，那怎么能够全面、多维度地管理这些整数？同余定理就提供了一个思路。因为不管你的模是几，最终得到的余数肯定都在一个范围内。比如我们上面除以7，就得到了星期几；我们除以2，就得到了奇偶数。所以按照这种方式, 我们就可以把无穷多个整数分成有限多个类。
 
求余的过程就是个哈希函数，将任意长度的输入，通过哈希算法，压缩为某一固定长度的输出。
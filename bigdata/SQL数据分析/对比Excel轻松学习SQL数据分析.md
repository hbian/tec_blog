### 异常值处理

""表示空值，缺失值有空格、null和空值三种表现形式，前两种形式虽然也表示缺失值，但是在对应的单元格内是有值的，而后一种空值是没有值的，表示这个单元格什么都没有。
如果缺失值是用空格表示的，要过滤掉缺失值，where后面就需要改成profession!= "<space> "；如果缺失值是用null表示的，要过滤掉缺失值，where后面就需要改成profession is not null。
COALESCE ( expression,value1,value2……,valuen) 
COALESCE()函数的第一个参数expression为待检测的表达式，而其后的参数个数不定。
COALESCE()函数将会返回包括expression在内的所有参数中的第一个非空表达式。
如果expression不为空值则返回expression；否则判断value1是否是空值，
如果value1不为空值则返回value1；否则判断value2是否是空值，
如果value2不为空值则返回value2；……以此类推，
如果所有的表达式都为空值，则返回NULL

MYSQL: IFNULL(expression,value) 

## 聚合计算
在使用group by的过程中，以下两点是人们比较常犯的错误：
* 除参加聚合运算的列外，要在select中查询的列必须先通过group by进行分组，因为没有进行分组的列是不会直接展示出来的，这些列只是在背后等着参与聚合运算，直接select这些列是查找不到的。
* group by后面的列名必须是原始表中的列名，而不能是select过程中起的别名。

为什么having后面可以使用别名，而group by后面不可以使用别名呢？这就涉及了SQL语句的执行顺序，group by的执行顺序是先于组内聚合运算及其对应的别名生成的，所以不能使用别名，因为别名还没有生成。而having的执行顺序是落后于组内聚合运算及其对应的别名生成的，所以可以使用别名。

## 窗口函数
over()函数的作用是将聚合结果显示在每条单独的记录中。
partition by的作用与group by类似，在over()函数中使用partition by来指明要按照哪列进行分组，然后聚合函数就会在分好的组内进行聚合运算

row_number()函数就是用来生成每条记录对应的行数的，即第几行。行数是按照数据存储的顺序进行生成的，且从1开始。因为行数是按照数据存储顺序生成的，所以一般row_number()函数与order by结合使用，此时的行数就表示排序，需要注意的是，row_number()函数的结果中不会出现重复值，即不会出现重复的行数，如果有两个相同的值，会按照表中存储的顺序来生成行数。

lag的英文意思是滞后，而lead的英文意思是超前。对应的lag()函数是让数据向后移动，而lead()函数是让数据向前移动。什么是向前移动，什么是向后移动。
如果我们现在想获取每个店铺本次销量与它前一次销量之差，只需要把该店铺的销量数据全部向后移动1行，这样本次销量数据就与前一次销量数据处于同一行，然后就可以直接做差进行比较了